小程序加载顺序：

1. 微信客户端下载整个小程序的代码包
2. 微信客户端打开小程序，通过app.json确定打开的页面
3. 执行app.js里的onLanch回调
4. 执行某个页面时（例如logs），先根据logs.json配置生成一个页面（包括顶部颜色、文字等）
5. 然后解析logs.wxml和logs.wxss，最后执行logs.js

---

### API

[API | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html)

小程序可以使用API，但是有一些API需要授权 [授权 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/authorize.html)

授权例子（以获取位置API为例）

```
{
  "pages":[
    "pages/index/index",
    "pages/logs/logs"
  ],
  "permission": {
    "scope.userLocation": {
      "desc": "位置"
    }
  },
}
```

获取位置授权之后，小程序右上角-设置 里可以看到授权情况（三个点会变成小飞机）

1. 事件监听API：以on开头的都是，这类函数接受一个回调函数作为参数，事件触发时调用这个回调函数，将相关参数传入

```
wx.onCompassChange(function (res) {
  console.log(res.direction)
})tongbu
```

2. 同步API：以Sync结尾的、以及一些其他的API是同步的，返回结果可以通过函数返回值获取。

```
try {
  wx.setStorageSync('key', 'value')
} catch (e) {
  console.error(e)
}
```

3. 异步API（大多数都是）callback方式：如wx.request、wx.login等。一般都接受一个Object类型的参数，其可以支持按需指定以下字段接受调用结果（一般都是依靠这些回调函数获取结果，也有部分异步API有返回值，如wx.request、wx.downloadFile等）

|   |   |   |   |
|---|---|---|---|
|**参数名**|**类型**|**必填**|**说明**|
|success|function|否|接口调用成功的回调函数|
|fail|function|否|接口调用失败的回调函数|
|complete|function|否|接口调用结束的回调函数（调用成功、失败都会执行）|
|其他|Any|-|接口定义的其他参数|

success，fail，complete 函数调用时会传入一个 Object 类型参数，包含以下字段：

|   |   |   |
|---|---|---|
|**属性**|**类型**|**说明**|
|errMsg|string|错误信息，如果调用成功返回 ${apiName}:ok|
|errCode|number|错误码，仅部分 API 支持，具体含义请参考对应 API 文档，成功时为 0。|
|其他|Any|接口返回的其他数据|

```
// callback形式调用
wx.login({
  success(res) {
    console.log(res.code)
  }
})
```

4. 异步API新增支持Promise返回

[2.10.2](https://developers.weixin.qq.com/miniprogram/dev/framework/compatibility.html) 以后异步API支持Promise的方式，如果不调用callback，就会返回一个Promise。如果调用callback，就不会有返回值。

```
// promise 形式调用
wx.chooseImage().then(res => console.log('res: ', res))
```

对于本来就有返回值的，如wx.request、wx.downloadFile等，不会返回Promise。（文档原话：它们的promisify需要开发者自行封装）

当没有回调参数时，异步接口返回 promise。此时若函数调用失败进入 fail 逻辑， 会报错提示 Uncaught (in promise)，开发者可通过 catch 来进行捕获。

[wx.onUnhandledRejection(function listener) | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/app-event/wx.onUnhandledRejection.html) 可以监听未处理的 Promise 拒绝事件

---

### JSON

每个页面的JSON优先级**高于**整体的app.json优先级，可以单独设置每个页面的顶部文字navigationBarTitleText

常用配置如下

```
{
  "navigationBarBackgroundColor": "#ffffff",
  "navigationBarTextStyle": "black",
  "navigationBarTitleText": "微信接口功能演示",
  "backgroundColor": "#eeeeee",
  "backgroundTextStyle": "light"
}
```

---

### sitemap

设置小程序各个页面是否可被微信索引，例如下面的是所有页面都会被索引

```
{
  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",
  "rules": [{
  "action": "allow",
  "page": "*"
  }]
}
```

---

### tabbar

```
"tabBar": {
    "list": [{
      "pagePath": "pages/index/index",
      "text": "首页"
    }, {
      "pagePath": "pages/logs/logs",
      "text": "日志"
    }]
  },
```

---

### 场景值

[微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/reference/scene-list.html)

场景值代表小程序来源，例如

|   |   |
|---|---|
|**场景值ID**|**说明**|
|1000|其他|
|1001|发现页小程序「最近使用」列表（基础库2.2.4-2.29.0版本包含「我的小程序」列表，2.29.1版本起仅为「最近使用」列表）|
|1005|微信首页顶部搜索框的搜索结果页|
|1006|发现栏小程序主入口搜索框的搜索结果页|

[Object wx.getLaunchOptionsSync() | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/api/base/app/life-cycle/wx.getLaunchOptionsSync.html)

这个api可以返回启动路径、**场景值**、来源等

---

### 逻辑层 App service

[逻辑层 App Service | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/)

小程序的js在小程序启动的时候运行，直到小程序销毁，类似 [ServiceWorker](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)

在js的基础上，小程序加入以下功能：

- 增加 App 和 Page 方法，进行[程序注册](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/app.html)和[页面注册](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/page.html)。
- 增加 getApp 和 getCurrentPages 方法，分别用来获取 App 实例和当前页面栈。
- 提供丰富的 [API](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/api.html)，如微信用户数据，扫一扫，支付等微信特有能力。
- 提供[模块化](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%A8%A1%E5%9D%97%E5%8C%96)能力，每个页面有独立的[作用域](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/module.html#%E6%96%87%E4%BB%B6%E4%BD%9C%E7%94%A8%E5%9F%9F)。

但是，它没有运行在浏览器上，没有办法获取window和document对象

---

### 注册小程序(App)

通过App方法可以注册App，里面可设置生命周期回调、全局变量等

通过getApp方法可以在任何页面获取app实例，并且可以直接访问其全局变量

```
// xxx.js
const appInstance = getApp()
console.log(appInstance.globalData) // I am global data
```

---

### 注册页面

Page方法，可以设定数据、生命周期回调、事件处理函数（例如触底，还有自定义的事件等）

[behaviors](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/behaviors.html) 可以将多个页面共用的数据、方法提取出来复用

[Component构造器](https://developers.weixin.qq.com/miniprogram/dev/framework/custom-component/component.html) 和Page的区别在于方法要放在methods对象里，适合复杂的页面

---

### 路由

[页面路由 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/route.html)

页面路由由栈管理，由getCurrentPages函数可以获取当前页面栈

|   |   |
|---|---|
|**路由方式**|**页面栈表现**|
|初始化|新页面入栈|
|打开新页面|新页面入栈|
|页面重定向|当前页面出栈，新页面入栈|
|页面返回|页面不断出栈，直到目标返回页|
|Tab 切换|页面全部出栈，只留下新的 Tab 页面|
|重加载|页面全部出栈，只留下新的页面|

总结路由和声明周期的关系：出栈会触发onHide，第一次入栈会触发onLoad，之后再入栈会触发onShow（如果入栈后出栈，再次入栈也视为第一次入栈）

- navigateTo, redirectTo 只能打开非 tabBar 页面。
- switchTab 只能打开 tabBar 页面。
- reLaunch 可以打开任意页面。
- 页面底部的 tabBar 由页面决定，即只要是定义为 tabBar 的页面，底部都有 tabBar。
- 调用页面路由带的参数可以在目标页面的onLoad中获取。

---

### 文件作用域

不同文件有不同作用域。App方法里可以定义全局变量。

---

### 模板

[WXML | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/)

可以通过template的name属性命名模板，然后用template的is属性根据模板名来指定要使用的模板，根据data属性确定要传递的数据

```
<!--wxml-->
<template name="staffName">
  <view>
    FirstName: {{firstName}}, LastName: {{lastName}}
  </view>
</template>

<template is="staffName" data="{{...staffA}}"></template>
<template is="staffName" data="{{...staffB}}"></template>
<template is="staffName" data="{{...staffC}}"></template>
```

```
// page.js
Page({
  data: {
    staffA: {firstName: 'Hulk', lastName: 'Hu'},
    staffB: {firstName: 'Shang', lastName: 'You'},
    staffC: {firstName: 'Gideon', lastName: 'Lin'}
  }
})
```

### 样式

[WXML | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/)

使用@import导入外联样式

```
/** common.wxss **/
.small-p {
  padding:5px;
}
```

```
/** app.wxss **/
@import "common.wxss";
.middle-p {
  padding:15px;
}
```

---

建议：**静态的样式统一写到 class 中**。**style 接收动态的样式**，在运行时会进行解析，请尽量避免将静态的样式写进 style 中，以免影响渲染速度

```
<view style="color:{{color}};" />
```

---

全局样式与局部样式

定义在 app.wxss 中的样式为全局样式，作用于每一个页面。在 page 的 wxss 文件中定义的样式为局部样式，只作用在对应的页面，并会覆盖 app.wxss 中相同的选择器。

### 简易的双向绑定

通过model:这个语法实现对单一字段的双向绑定

```
<input model:value="{{value}}" />
```

但是以下方式都非法

```
<input model:value="值为 {{value}}" />
<input model:value="{{ a + b }}" />
<input model:value="{{ a.b }}" />
```

### 自定义组件与双向绑定

```
// custom-component.js
Component({
  properties: {
    myValue: String
  }
})
```

```
<!-- custom-component.wxml -->
<input model:value="{{myValue}}" />
```

```
<custom-component model:my-value="{{pageValue}}" />
```

这样，当自定义组件中的输入框的内容变了，页面的this.data.pageValue会变，然后页面所有绑定了this.data.pageValue的位置也会一同更新

此外，还可以通过在组件中，用函数修改myValue，也会导致上述变化  
  

```
// custom-component.js
Component({
  properties: {
    myValue: String
  },
  methods: {
    update: function() {
      // 更新 myValue
      this.setData({
        myValue: 'leaf'
      })
    }
  }
})
```

如上面，触发update函数，和在输入框里修改输入为'leaf'，结果都是一样的。

### 组件

[视图容器 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/component/)

---

### 小程序的声明周期

[小程序运行机制 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html)



切到后台5秒后，小程序挂起，内存状态保存，但是进程停止。30min后/资源紧张时，内存状态也会销毁。

### Skyline

[Skyline 渲染引擎 / 概览 / 介绍 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/skyline/introduction.html)

小程序的逻辑层是App Service引擎（or线程？），视图层是WebView引擎

小程序有一个进一步优化的渲染引擎，名为Skyline，使得小程序更接近原生应用

WebView引擎在一个线程里处理JS、DOM创建、CSS解析、样式、Layout、Paint

而Skyline单独用一个渲染线程负责Layout、Paint等，并在AppService里划分一个`独立的上下文`用于JS、DOM创建等。

特点如下：

1. 不容易被逻辑阻塞
2. 无需为每一个页面创建一个`JS引擎实例`（WebView），减少内存消耗
3. 框架可以在页面之间共享更多资源
4. 框架之间无需`通过JSBridge进行数据交换`

### 分包

[使用分包 | 微信开放文档](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html)

通过在app.json的subpackages字段声明分包结构

```
{
  "pages":[
    "pages/index",
    "pages/logs"
  ],
  "subpackages": [
    {
      "root": "packageA",
      "pages": [
        "pages/cat",
        "pages/dog"
      ]
    }, {
      "root": "packageB",
      "name": "pack2",
      "pages": [
        "pages/apple",
        "pages/banana"
      ]
    }
  ]
}
```

- 声明 subpackages 后，将按 subpackages 配置路径进行打包，subpackages 配置路径外的目录将被打包到主包中
- 主包也可以有自己的 pages，即最外层的 pages 字段。
- subpackage 的根目录不能是另外一个 subpackage 内的子目录
- tabBar 页面必须在主包内

- packageA 无法 require packageB JS 文件，但可以 require 主包、packageA 内的 JS 文件；使用 [分包异步化](https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html) 时不受此条限制
- packageA 无法 import packageB 的 template，但可以 require 主包、packageA 内的 template
- packageA 无法使用 packageB 的资源，但可以使用主包、packageA 内的资源

似乎**主包的pages相互之间也无法require**，但是**分包却可以require主包的**，挺有意思的。